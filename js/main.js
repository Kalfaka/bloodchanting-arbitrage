/**
 * SpawnPK Arbitrage Calculator - Main Application
 * Entry point for the application
 */

import { TradeAPI } from './api.js';
import { ArbitrageCalculator, BloodchantingCalculator, formatGP, formatMillions } from './calculator.js';
import { DataCache } from './storage.js';

class ArbitrageApp {
  constructor() {
    // Get CORS proxy mode from global config
    const corsProxyMode = window.CORS_PROXY_MODE || 'allorigins';
    this.api = new TradeAPI(corsProxyMode);
    this.cache = new DataCache();
    this.shopConfigs = [];
    this.tradeData = [];
    this.bloodDiamondTrades = [];
    this.bloodchantingStoneTrades = [];
    this.opportunities = [];
    this.bloodchantingCalc = null;
    this.currentDateFilter = '24h';
    this.bloodchantingDateFilter = '24h';
    this.currentScenario = 'min';
  }

  /**
   * Initialize the application
   */
  async init() {
    console.log('Initializing SpawnPK Arbitrage Calculator...');

    // Load shop configurations
    await this.loadShopConfigs();

    // Load cached data if available
    const cached = this.cache.loadTradeData();
    if (cached) {
      this.showCachedData(cached);
    }

    // Setup event listeners
    this.setupEventListeners();

    // Load user preferences
    this.loadPreferences();

    // Show CORS notice if using proxy
    const corsProxyMode = window.CORS_PROXY_MODE || 'allorigins';
    if (corsProxyMode !== 'none') {
      document.getElementById('cors-notice').classList.remove('hidden');
    }

    console.log('Initialization complete');
  }

  /**
   * Load shop configuration files
   */
  async loadShopConfigs() {
    try {
      const [bloodShard, bloodSynthesis] = await Promise.all([
        fetch('data/blood_shard_shop.json').then(r => r.json()),
        fetch('data/blood_synthesis_shop.json').then(r => r.json())
      ]);

      this.shopConfigs = [bloodShard, bloodSynthesis];
      console.log('Shop configurations loaded:', this.shopConfigs.map(s => s.shop_name));

    } catch (error) {
      console.error('Error loading shop configs:', error);
      this.showError('Failed to load shop configurations. Please refresh the page.');
    }
  }

  /**
   * Load trade data from static JSON file (generated by GitHub Actions)
   * This is much faster and more reliable than fetching from API in browser
   */
  async fetchAllTradeData() {
    this.showLoading(true);
    this.updateStatus('Loading trade data...');

    this.tradeData = [];

    try {
      console.log('Loading trade data from static cache...');

      // Fetch the static JSON file (generated by GitHub Actions)
      const response = await fetch('data/trade_cache.json');

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();

      console.log('Trade data loaded successfully');
      console.log('Metadata:', data.metadata);

      // Extract trades from the cached data
      this.tradeData = data.trades || [];

      console.log(`Total trades loaded: ${this.tradeData.length}`);

      // Filter blood diamonds separately for bloodchanting calculator
      this.bloodDiamondTrades = this.tradeData.filter(trade =>
        trade.item_name.toLowerCase() === 'blood diamonds'
      );

      // Filter bloodchanting stones for market comparison (item_id: 22108)
      this.bloodchantingStoneTrades = this.tradeData.filter(trade =>
        trade.item_name.toLowerCase() === 'bloodchanting stone' || trade.item_id === 22108
      );

      console.log(`Blood diamond trades: ${this.bloodDiamondTrades.length}`);
      console.log(`Bloodchanting stone trades: ${this.bloodchantingStoneTrades.length}`);

      // Update last updated time from metadata
      if (data.metadata && data.metadata.last_updated) {
        const lastUpdated = new Date(data.metadata.last_updated);
        this.displayLastUpdated(lastUpdated);
      }

      // Calculate and render
      this.calculateAndRender();
      this.showLoading(false);
      this.updateStatus(`Loaded ${this.tradeData.length} trades successfully`);

    } catch (error) {
      console.error('Error loading trade data:', error);
      this.showLoading(false);
      this.showError('Failed to load trade data. The data file may not exist yet. Please wait for GitHub Actions to generate it, or check the console for details.');
    }
  }

  /**
   * Display last updated time from metadata
   */
  displayLastUpdated(date) {
    const lastUpdatedEl = document.getElementById('last-updated');
    if (lastUpdatedEl) {
      const timeStr = date.toLocaleString();
      lastUpdatedEl.textContent = `Last updated: ${timeStr}`;
    }
  }

  /**
   * Calculate opportunities and render results
   */
  calculateAndRender() {
    console.log('Calculating opportunities with date filter:', this.currentDateFilter);
    console.log('Bloodchanting calculator date filter:', this.bloodchantingDateFilter);

    // Calculate opportunities with current date filter (for table display)
    const calculator = new ArbitrageCalculator(
      this.shopConfigs,
      this.tradeData,
      this.currentDateFilter
    );
    this.opportunities = calculator.calculateOpportunities();

    // Calculate opportunities with bloodchanting date filter (for calculator)
    const bloodchantingCalculator = new ArbitrageCalculator(
      this.shopConfigs,
      this.tradeData,
      this.bloodchantingDateFilter
    );
    const bloodchantingOpportunities = bloodchantingCalculator.calculateOpportunities();

    // Separate by shop for bloodchanting calculator
    const shardOpps = bloodchantingOpportunities.filter(o => o.shop_name === 'Blood Shard Shop');
    const tokenOpps = bloodchantingOpportunities.filter(o => o.shop_name === 'Blood Synthesis Shop');

    console.log(`Blood Shard opportunities: ${shardOpps.length}`);
    console.log(`Blood Synthesis opportunities: ${tokenOpps.length}`);

    // Calculate bloodchanting stone cost with separate date filter
    const bloodchantingCalc = new BloodchantingCalculator(
      shardOpps,
      tokenOpps,
      this.bloodDiamondTrades,
      this.bloodchantingDateFilter
    );
    this.bloodchantingCalc = bloodchantingCalc.calculate();

    // Calculate bloodchanting stone market price
    this.bloodchantingStoneStats = this.calculateBloodchantingStoneMarketPrice();

    // Render everything
    this.updateSortDropdownLabels();
    this.renderBloodchanting();
    this.renderTable();
  }

  /**
   * Calculate bloodchanting stone market price statistics
   */
  calculateBloodchantingStoneMarketPrice() {
    const filteredTrades = this.api.filterByDateRange(
      this.bloodchantingStoneTrades,
      this.bloodchantingDateFilter
    );

    if (filteredTrades.length === 0) {
      return null;
    }

    const pricesGP = filteredTrades.map(t => this.api.convertToGPPerUnit(t));
    const sortedPrices = [...pricesGP].sort((a, b) => a - b);

    return {
      min_price_gp: sortedPrices[0],
      avg_price_gp: pricesGP.reduce((a, b) => a + b, 0) / pricesGP.length,
      max_price_gp: sortedPrices[sortedPrices.length - 1],
      trade_count: filteredTrades.length
    };
  }

  /**
   * Render bloodchanting calculator results
   */
  renderBloodchanting() {
    const display = document.getElementById('bloodchanting-display');
    display.innerHTML = this.renderBloodchantingCalculation(this.bloodchantingCalc, this.currentScenario);
  }

  /**
   * Render bloodchanting calculation HTML
   */
  renderBloodchantingCalculation(calculation, scenario) {
    if (!calculation) {
      return `<p class="text-osrs-light text-center py-8">No data available</p>`;
    }

    if (calculation.error) {
      return `
        <div class="error-message">
          ${calculation.error}
        </div>
      `;
    }

    const result = calculation[scenario];
    if (!result) {
      return `<p class="text-osrs-light text-center py-8">Unable to calculate</p>`;
    }

    const shard = result.shard_component;
    const token = result.token_component;
    const diamond = result.diamond_component;

    // Get the prices per item for each component
    const shardPricePerItem = shard.total_cost_millions / shard.items_to_buy;
    const tokenPricePerItem = token.total_cost_millions / token.items_to_buy;

    // Determine the heading text based on scenario
    const headingText = scenario === 'min' ? 'Best cost to craft 1 bloodchanting stone' : 'Average cost to craft 1 bloodchanting stone';

    // Market comparison HTML
    let marketComparisonHTML = '';
    if (this.bloodchantingStoneStats && this.bloodchantingStoneStats.trade_count > 0) {
      const marketPrice = scenario === 'min'
        ? this.bloodchantingStoneStats.min_price_gp / 1_000_000
        : this.bloodchantingStoneStats.avg_price_gp / 1_000_000;
      const craftCost = result.total_cost_millions;
      const difference = marketPrice - craftCost;
      const profitOrLoss = difference > 0 ? 'profit' : 'loss';
      const profitOrLossText = difference > 0
        ? `${formatMillions(difference)} profit if you sell`
        : `${formatMillions(Math.abs(difference))} cheaper to craft`;

      marketComparisonHTML = `
        <!-- Market Comparison -->
        <div class="osrs-stat-box text-center">
          <div class="text-sm text-osrs-light">Market Price (${scenario === 'min' ? 'Min' : 'Avg'})</div>
          <div class="text-2xl font-bold text-osrs-gold mt-2">${formatMillions(marketPrice)}</div>
          <div class="text-sm ${difference > 0 ? 'text-green-400' : 'text-osrs-light'} mt-1">
            ${profitOrLossText}
          </div>
          <div class="text-xs text-osrs-light mt-1">${this.bloodchantingStoneStats.trade_count} trades in range</div>
        </div>
      `;
    }

    return `
      <div class="space-y-4">
        <!-- Total Cost and Market Comparison -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div class="osrs-stat-box text-center">
            <div class="text-sm text-osrs-light">${headingText}</div>
            <div class="text-3xl font-bold text-osrs-gold mt-2">${formatMillions(result.total_cost_millions)}</div>
          </div>
          ${marketComparisonHTML}
        </div>

        <!-- Components Grid -->
        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
          <!-- Blood Shards Component -->
          <div class="component-box">
            <h4>Blood Shards (250 needed)</h4>
            <p><strong>Buy:</strong> ${shard.items_to_buy}x ${shard.item_name}</p>
            <p><strong>Price per item:</strong> ${formatMillions(shardPricePerItem)}</p>
            <p><strong>Receive:</strong> ${shard.total_shards_received} shards (${shard.shards_per_item} per item)</p>
            <p><strong>Cost per shard:</strong> ${formatMillions(shard.cost_per_shard)}</p>
            <p class="component-total"><strong>Subtotal:</strong> ${formatMillions(shard.total_cost_millions)}</p>
          </div>

          <!-- Blood Synthesis Tokens Component -->
          <div class="component-box">
            <h4>Blood Synthesis Tokens (500 needed)</h4>
            <p><strong>Buy:</strong> ${token.items_to_buy}x ${token.item_name}</p>
            <p><strong>Price per item:</strong> ${formatMillions(tokenPricePerItem)}</p>
            <p><strong>Receive:</strong> ${token.total_tokens_received.toLocaleString()} tokens (${token.tokens_per_item.toLocaleString()} per item)</p>
            <p><strong>Cost per token:</strong> ${formatMillions(token.cost_per_token)}</p>
            <p class="component-total"><strong>Subtotal:</strong> ${formatMillions(token.total_cost_millions)}</p>
          </div>

          <!-- Blood Diamonds Component -->
          <div class="component-box">
            <h4>Blood Diamonds (10 needed)</h4>
            <p><strong>Buy:</strong> ${diamond.diamonds_to_buy}x Blood diamonds</p>
            <p><strong>Price per diamond:</strong> ${formatMillions(diamond.cost_per_diamond)}</p>
            <p class="component-total"><strong>Subtotal:</strong> ${formatMillions(diamond.total_cost_millions)}</p>
          </div>
        </div>

        <!-- Shopping List -->
        <div class="shopping-list">
          <h4>Kalfka reccomends...</h4>
          <ul>
            <li>Buy ${shard.items_to_buy}x ${shard.item_name} at ${formatMillions(shardPricePerItem)} each (get ${shard.total_shards_received} shards, use 250)</li>
            <li>Buy ${token.items_to_buy}x ${token.item_name} at ${formatMillions(tokenPricePerItem)} each (get ${token.total_tokens_received.toLocaleString()} tokens, use 500)</li>
            <li>Buy ${diamond.diamonds_to_buy}x Blood diamonds at ${formatMillions(diamond.cost_per_diamond)} each</li>
          </ul>
        </div>
      </div>
    `;
  }

  /**
   * Render opportunities table
   */
  renderTable() {
    const tbody = document.getElementById('table-body');
    const thead = document.getElementById('table-head');
    tbody.innerHTML = '';

    let filtered = this.filterOpportunities();
    filtered = this.sortOpportunities(filtered);

    // Update table headers based on selected shop
    const selectedShop = document.getElementById('shop-select').value;
    const currencyLabel = selectedShop === 'Blood Shard Shop' ? 'Shards' :
                          selectedShop === 'Blood Synthesis Shop' ? 'Tokens' :
                          'Shards/Tokens';
    const costMinLabel = selectedShop === 'Blood Shard Shop' ? 'Cost/Shard (Min)' :
                         selectedShop === 'Blood Synthesis Shop' ? 'Cost/Token (Min)' :
                         'Cost/Currency (Min)';
    const costAvgLabel = selectedShop === 'Blood Shard Shop' ? 'Cost/Shard (Avg)' :
                         selectedShop === 'Blood Synthesis Shop' ? 'Cost/Token (Avg)' :
                         'Cost/Currency (Avg)';

    thead.innerHTML = `
      <tr>
        <th class="text-left">Item</th>
        <th class="text-left">Shop</th>
        <th class="text-right">${currencyLabel}</th>
        <th class="text-right">Min Price</th>
        <th class="text-right">Avg Price</th>
        <th class="text-right">Max Price</th>
        <th class="text-right">${costMinLabel}</th>
        <th class="text-right">${costAvgLabel}</th>
        <th class="text-center">Trades</th>
      </tr>
    `;

    if (filtered.length === 0) {
      tbody.innerHTML = `
        <tr>
          <td colspan="9" class="text-center text-osrs-light py-8">
            No items match the current filters
          </td>
        </tr>
      `;
      return;
    }

    for (const opp of filtered) {
      const row = this.createTableRow(opp);
      tbody.appendChild(row);
    }

    this.updateStatus(`Showing ${filtered.length} items (Date filter: ${this.currentDateFilter})`);
  }

  /**
   * Create a table row for an opportunity
   */
  createTableRow(opportunity) {
    const row = document.createElement('tr');
    const hasData = opportunity.min_price_gp !== null;

    if (!hasData) {
      row.classList.add('no-data');
    }

    row.innerHTML = `
      <td class="font-bold text-osrs-gold">${opportunity.item_name}</td>
      <td class="text-osrs-light">${opportunity.shop_name}</td>
      <td class="text-right text-osrs-gold">${opportunity.tokens_received.toLocaleString()}</td>
      <td class="text-right font-mono text-osrs-gold">${hasData ? formatGP(opportunity.min_price_gp) : 'No data'}</td>
      <td class="text-right font-mono text-osrs-gold">${hasData ? formatGP(opportunity.avg_price_gp) : 'No data'}</td>
      <td class="text-right font-mono text-osrs-gold">${hasData ? formatGP(opportunity.max_price_gp) : 'No data'}</td>
      <td class="text-right font-mono font-bold text-osrs-gold">${hasData ? formatMillions(opportunity.cost_per_token_min) : '-'}</td>
      <td class="text-right font-mono font-bold text-osrs-gold">${hasData ? formatMillions(opportunity.cost_per_token_avg) : '-'}</td>
      <td class="text-center text-osrs-light">${opportunity.trade_count}</td>
    `;

    return row;
  }

  /**
   * Update Sort By dropdown labels based on selected shop
   */
  updateSortDropdownLabels() {
    const selectedShop = document.getElementById('shop-select').value;
    const sortSelect = document.getElementById('sort-select');

    const costMinLabel = selectedShop === 'Blood Shard Shop' ? 'Cost/Shard (Min Price)' :
                         selectedShop === 'Blood Synthesis Shop' ? 'Cost/Token (Min Price)' :
                         'Cost/Currency (Min Price)';
    const costAvgLabel = selectedShop === 'Blood Shard Shop' ? 'Cost/Shard (Avg Price)' :
                         selectedShop === 'Blood Synthesis Shop' ? 'Cost/Token (Avg Price)' :
                         'Cost/Currency (Avg Price)';

    sortSelect.options[0].text = costMinLabel;
    sortSelect.options[1].text = costAvgLabel;
  }

  /**
   * Filter opportunities by selected shop
   */
  filterOpportunities() {
    const selectedShop = document.getElementById('shop-select').value;

    if (selectedShop === 'all') {
      return this.opportunities;
    }

    return this.opportunities.filter(opp => opp.shop_name === selectedShop);
  }

  /**
   * Sort opportunities by selected criteria
   */
  sortOpportunities(opportunities) {
    const sortBy = document.getElementById('sort-select').value;

    const sorters = {
      'cost_min': (a, b) => {
        if (a.cost_per_token_min === null) return 1;
        if (b.cost_per_token_min === null) return -1;
        return a.cost_per_token_min - b.cost_per_token_min;
      },
      'cost_avg': (a, b) => {
        if (a.cost_per_token_avg === null) return 1;
        if (b.cost_per_token_avg === null) return -1;
        return a.cost_per_token_avg - b.cost_per_token_avg;
      },
      'name': (a, b) => a.item_name.localeCompare(b.item_name)
    };

    return [...opportunities].sort(sorters[sortBy]);
  }

  /**
   * Setup event listeners
   */
  setupEventListeners() {
    // Refresh button
    document.getElementById('refresh-btn').addEventListener('click', () => {
      this.fetchAllTradeData();
    });

    // Bloodchanting date filter - triggers recalculation for bloodchanting only
    document.getElementById('bloodchanting-date-select').addEventListener('change', (e) => {
      this.bloodchantingDateFilter = e.target.value;
      if (this.tradeData.length > 0) {
        this.calculateAndRender();
      }
      this.savePreferences();
    });

    // Date filter - triggers recalculation
    document.getElementById('date-select').addEventListener('change', (e) => {
      this.currentDateFilter = e.target.value;
      if (this.tradeData.length > 0) {
        this.calculateAndRender();
      }
      this.savePreferences();
    });

    // Shop filter - only affects table display
    document.getElementById('shop-select').addEventListener('change', () => {
      if (this.opportunities.length > 0) {
        this.updateSortDropdownLabels();
        this.renderTable();
      }
      this.savePreferences();
    });

    // Sort select - only affects table display
    document.getElementById('sort-select').addEventListener('change', () => {
      if (this.opportunities.length > 0) {
        this.renderTable();
      }
      this.savePreferences();
    });

    // Scenario tabs
    document.querySelectorAll('.scenario-tab').forEach(tab => {
      tab.addEventListener('click', (e) => {
        document.querySelectorAll('.scenario-tab').forEach(t => t.classList.remove('active'));
        e.target.classList.add('active');
        this.currentScenario = e.target.dataset.scenario;
        this.renderBloodchanting();
      });
    });
  }

  /**
   * Save user preferences to localStorage
   */
  savePreferences() {
    const prefs = {
      sortBy: document.getElementById('sort-select').value,
      selectedShop: document.getElementById('shop-select').value,
      dateFilter: this.currentDateFilter,
      bloodchantingDateFilter: this.bloodchantingDateFilter
    };
    this.cache.savePreferences(prefs);
  }

  /**
   * Load user preferences from localStorage
   */
  loadPreferences() {
    const prefs = this.cache.loadPreferences();
    document.getElementById('sort-select').value = prefs.sortBy;
    document.getElementById('shop-select').value = prefs.selectedShop;
    document.getElementById('date-select').value = prefs.dateFilter;
    document.getElementById('bloodchanting-date-select').value = prefs.bloodchantingDateFilter || prefs.dateFilter;
    this.currentDateFilter = prefs.dateFilter;
    this.bloodchantingDateFilter = prefs.bloodchantingDateFilter || prefs.dateFilter;
  }

  /**
   * Display cached data
   */
  showCachedData(cached) {
    this.tradeData = cached.trades;
    this.bloodDiamondTrades = cached.bloodDiamonds || [];
    this.calculateAndRender();

    const age = Date.now() - cached.timestamp;
    const minutes = Math.floor(age / 60000);
    this.updateStatus(`Using cached data (${minutes} min old)`);
    this.updateLastUpdated(new Date(cached.timestamp));
  }

  /**
   * Show/hide loading indicator
   */
  showLoading(show) {
    const loading = document.getElementById('loading');
    if (show) {
      loading.classList.remove('hidden');
    } else {
      loading.classList.add('hidden');
    }
  }

  /**
   * Update status text
   */
  updateStatus(message) {
    document.getElementById('status-text').textContent = message;
  }

  /**
   * Update last updated timestamp
   */
  updateLastUpdated(date = new Date()) {
    const formatted = date.toLocaleString();
    document.getElementById('last-updated').textContent = `Last updated: ${formatted}`;
  }

  /**
   * Show error message
   */
  showError(message) {
    this.updateStatus(`Error: ${message}`);
    console.error(message);
  }
}

// Initialize the app when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  const app = new ArbitrageApp();
  app.init();
});
